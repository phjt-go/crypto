# 简介
包sha3实现了SHA-3固定输出长度哈希函数和FIPS-202定义的SHAKE可变输出长度哈希函数。
这两种哈希函数都使用“sponge”结构和Keccak置换。有关详细规范，请参见http://keccak.noekeon.org/

如果您不确定需要什么函数，请使用SHAKE256，至少输出64字节。SHAKE实例比SHA3实例快;后者必须分配内存以符合哈希。散列接口。

如果您需要密钥MAC(消息身份验证代码)，请将密钥放在输入之前，使用SHAKE256散列并读取至少32字节的输出。

# 安全优势  
SHA3-x (x = 224、256、384或512)函数对x位的原图像攻击具有安全强度。因为它们只产生“x”位的输出，所以它们的抗碰撞能力只有“x/2”位。

SHAKE-256和-128函数的一般安全强度为256位和128位，以抵御所有攻击，前提是至少使用它们输出的2x位。请求64或32字节以上的输出并不会增加SHAKE函数的抗碰撞能力。

# sponge 函数：
sponge通过将置换应用于“速率+容量”字节的状态，但隐藏字节的“容量”，从公共伪随机置换构建伪随机函数。

sponge从零状态开始。要使用sponge对输入进行哈希，输入的“速率”字节要与海绵的状态相异。
然后，sponge被“填满”，排列应用于“空”它。这个过程重复进行，直到所有输入都被“吸收”为止。然后填充输入。摘要以同样的方式从sponge中“挤压”出来，只不过输出输出是复制出来的，而不是输入输入。

sponge的一般安全强度参数化，等于其容量的一半;容量+速率等于排列的宽度。由于KeccakF-1600排列是1600位(200字节)宽，这意味着海绵实例的安全强度等于(1600 -比特率)/ 2

# 推荐
大多数新用途都推荐使用SHAKE功能。它们可以产生任意长度的输出。SHAKE256的输出长度至少为64字节，提供了256位安全性，可以抵御所有攻击。
Keccak团队推荐它用于从SHA2-512升级的大多数应用程序。(NIST为SHA3-512选择了一个更强但更慢的海绵实例。)

SHA-3函数是SHA-2函数的“插入式”替换。它们产生相同长度的输出，具有抵御所有攻击的相同安全强度。这意味着，特别地，SHA3-256只有128位的碰撞阻力，因为它的输出长度是32字节。
package sha3


### 代码走读
 序号 | Go文件/函数或方法 | 作用 
:---: |:---: | :---:
 1 | hashes.go | 该文件提供了用于创建SHA-3和SHAKE散列函数实例的函数，以及用于散列字节的实用函数。
     &nbsp; | `NewKeccak256` | 创建一个新的Keccak-256散列
     &nbsp; | `NewKeccak512`  | 创建一个新的Keccak-512散列
     &nbsp; | `New224`  | 创建一个新的SHA3-224散列
     &nbsp; | `New256`  | 创建一个新的SHA3-256散列
     &nbsp; | `New384`  | 创建一新的SHA3-384散列
     &nbsp; | `New512`  | 创建一个新的SHA3-512散列
     &nbsp; | `Sum224`  | 返回数据的SHA3-224摘要。
     &nbsp; | `Sum256`  | 返回数据的SHA3-256摘要。
     &nbsp; | `Sum384`  | 返回数据的SHA3-384摘要。
     &nbsp; | `Sum512`  | 返回数据的SHA3-512摘要。
 2 | keccakf.go  | 加密算法的实现，属于底层代码
 3 | keccakf_amd64.go  | 一个内部函数，该函数在keccakf_amd64.s中实现。
 4 | register.go  | init初始化方法注册SHA3_224、SHA3_256、SHA3_384、SHA3_512等函数，从而获得给定哈希函数的新实例
 5 | sha3.go  | 提供了包括Hsah常用的BlockSizeClone、Size、Reset、Write、Read、Sum等方法
     &nbsp; | `BlockSize` | 返回海绵底层这个散列函数的速度
     &nbsp; | `Clone` | 返回一个克隆后的哈希函数
     &nbsp; | `Size` | 返回哈希函数的输出大小
     &nbsp; | `Reset` | 通过对海绵状态和字节缓冲区进行归零，并设置海绵来清除内部状态。吸收状态
     &nbsp; | `Write` |  将更多的数据写到哈希的状态中。如果在写入之后向ShakeHash写入更多数据，则会产生错误
     &nbsp; | `Read` | 从海绵中挤压任意数量的字节
     &nbsp; | `Sum` | 对哈希状态应用填充，然后挤压出所需的输出字节数
 6 | shake.go  | 这个文件定义了ShakeHash接口，并提供了创建SHAKE实例的函数，以及将字节散列到任意长度输出的实用函数。
     &nbsp;| ==`PubKey`== | 会返回与此私钥对应的公钥
 7 | xor_Unaligned  | 非对称的异或运算内部函数


 
#### 单元测试 


序号 | Go文件/测试用例方法 | 说明
:---:| :---: | :---:
 1 | sha3_test.go | 提供了基于各个散列函数的常规测试方法和压测方法
     &nbsp;| `TestKeccakKats` | 测试SHA-3和Shake实现
     &nbsp;| `TestUnalignedWrite` | 测试将数据写入具有较小输入缓冲区的任意模式。
     &nbsp;| `TestAppend` | 测试在需要重新分配时追加是否有效。
     &nbsp;| `TestAppendNoRealloc` | 测试在不需要重新分配的情况下追加是否有效.
     &nbsp;| `TestSqueezing` | 测试一次压缩完整输出是否与重复压缩实例产生相同的输出。
     &nbsp;| `BenchmarkPermutationFunction` | 在没有输入数据的情况下测量置换函数的速度。
     &nbsp;| `BenchmarkSha3_512_MTU` | 压测1个矿工时长度为1350的Sha3_384散列哈希进行哈希的速度和最大传输效率。
     &nbsp;| `BenchmarkSha3_384_MTU` | 压测1个矿工时长度为1350的Sha3_512散列哈希进行哈希的速度和最大传输效率。
     &nbsp;| `BenchmarkSha3_256_MTU` | 压测1个矿工时长度为1350的Sha3_256散列哈希进行哈希的速度和最大传输效率。
     &nbsp;| `BenchmarkSha3_224_MTU` | 压测1个矿工时长度为1350的Sha3_224散列哈希进行哈希的速度和最大传输效率。
     &nbsp;| `BenchmarkShake128_MTU` | 压测1个矿工时长度为1350的NewShake128哈希函数的清零、读和写的速度
     &nbsp;| `BenchmarkShake256_MTU` | 压测1个矿工时长度为1350的NewShake256哈希函数的清零、读和写的速度
     &nbsp;| `BenchmarkShake256_16x` | 压测1024个矿工时长度为16的NewShake256哈希函数的清零、读和写的速度
     &nbsp;| `BenchmarkShake256_1MiB` | 压测1024个矿工时长度为1350的NewShake256哈希函数的清零、读和写的速度
     &nbsp;| `BenchmarkSha3_512_1MiB` | 压测1024个矿工时长度为1024的SHA3-512散列哈希进行哈希的速度
 
     
